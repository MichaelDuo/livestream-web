{"version":3,"sources":["../../../../src/streaming/StreamProcessor.js"],"names":["StreamProcessor","config","context","eventBus","getInstance","streamInfo","type","errHandler","mimeType","timelineConverter","adapter","manifestModel","mediaPlayerModel","fragmentModel","abrController","playbackController","mediaController","textController","dashMetrics","settings","boxParser","instance","isDynamic","mediaInfo","mediaInfoArr","bufferController","scheduleController","representationController","liveEdgeFinder","indexHandler","streamInitialized","setup","resetInitialSettings","on","Events","STREAM_INITIALIZED","onStreamInitialized","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","QUALITY_CHANGE_REQUESTED","onQualityChanged","INIT_FRAGMENT_NEEDED","onInitFragmentNeeded","MEDIA_FRAGMENT_NEEDED","onMediaFragmentNeeded","MEDIA_FRAGMENT_LOADED","onMediaFragmentLoaded","BUFFER_LEVEL_UPDATED","onBufferLevelUpdated","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","BUFFER_CLEARED","onBufferCleared","SEEK_TARGET","onSeekTarget","initialize","mediaSource","hasVideoTrack","create","baseURLController","events","errors","Errors","debug","requestModifier","dashConstants","DashConstants","constants","Constants","urlUtils","manifestInfo","registerStreamType","streamId","id","createBufferControllerForType","getIsTextTrack","TIMED_TEXT_REQUESTED","onTimedTextRequested","reset","errored","keepBuffers","unRegisterStreamType","off","isUpdating","e","setTimeSyncCompleted","setLiveEdgeSeekTarget","seekTarget","getStreamStartTime","setSeekStartTime","setCurrentRepresentation","getRepresentationInfo","setSeekTarget","start","sender","getType","getStreamId","error","convertDataToRepresentationInfo","currentRepresentation","code","SEGMENTS_UPDATE_FAILED_ERROR_CODE","addDVRMetric","mediaType","representationInfo","newQuality","pushPlayListTraceMetrics","Date","PlayListTrace","REPRESENTATION_SWITCH_STOP_REASON","createPlaylistTraceMetrics","getTime","getPlaybackRate","addBufferLevel","bufferLevel","getValue","doNotUpdateDVRWindowOnBufferUpdated","addBufferState","state","getBufferTarget","MetricsConstants","BUFFER_EMPTY","isSeeking","REBUFFERING_REASON","unintended","removeExecutedRequestsAfterTime","from","syncExecutedRequestsWithBufferedRange","getBuffer","getAllBufferRanges","duration","range","calcSegmentAvailabilityRange","getCurrentRepresentation","addDVRInfo","getRepresentationController","setBuffer","buffer","getBufferController","getFragmentModel","updateStreamInfo","newStreamInfo","getStreamInfo","selectMediaInfo","newMediaInfo","newRealAdaptation","getRealAdaptation","voRepresentations","getVoRepresentations","realAdaptation","getData","maxQuality","getTopQualityIndexFor","minIdx","getMinAllowedIndexFor","quality","averageThroughput","bitrate","FRAGMENTED_TEXT","getThroughputHistory","getAverageThroughput","getInitialBitrateFor","getQualityForBitrate","getQualityFor","undefined","setMimeType","updateData","addMediaInfo","selectNewMediaInfo","indexOf","push","getMediaInfoArr","getMediaInfo","getMediaSource","setMediaSource","dischargePreBuffer","getScheduleController","voRepresentation","getRepresentationForQuality","isBufferingCompleted","getIsBufferingCompleted","getBufferLevel","representationId","appendInitSegment","request","getInitRequest","processInitRequest","getIsPruningInProgress","findNextRequest","replacement","NaN","isNaN","startTime","setIndexHandlerTime","delayLoadingTime","getTimeToLoadDelay","setTimeToLoadDelay","processMediaRequest","requestToReplace","hasSeekTarget","currentTime","getNormalizedTime","time","getIndexHandlerTime","bufferIsDivided","isTextEnabled","getRangeAt","playingRange","end","hasDiscontinuities","hasDiscontinuitiesAfter","getFragmentRequest","timeThreshold","ignoreIsFinished","keepIdx","action","FragmentRequest","ACTION_COMPLETE","isFragmentLoaded","representation","index","chunk","bytes","eventStreamMedia","getEventsFor","eventStreamTrack","length","getRequests","FragmentModel","FRAGMENT_MODEL_EXECUTED","handleInbandEvents","trigger","ADD_INBAND_EVENTS_REQUESTED","data","mediaInbandEvents","trackInbandEvents","fragmentStartTime","Math","max","eventStreams","inbandEvents","concat","i","ln","schemeIdUri","value","isoFile","parse","eventBoxes","getBoxes","event","getEvent","createBuffer","previousBuffers","switchTrackAsked","controller","DashJSError","MEDIASOURCE_TYPE_UNSUPPORTED_CODE","MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE","VIDEO","AUDIO","currentRepresentationInfo","liveEdge","getLiveEdge","computeLiveDelay","fragmentDuration","DVRWindowSize","get","streaming","lowLatencyEnabled","liveStartTime","getLiveDelay","setLiveStartTime","seek","updateManifestUpdateInfo","presentationStartTime","latency","clientTimeOffset","getClientTimeOffset","setCurrentTime","getCurrentTime","resetIndexHandler","resetIndex","options","fragRequest","getSegmentRequestForTime","getNextSegmentRequest","finalisePlayList","reason","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"StreamProcessor.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport DashConstants from '../dash/constants/DashConstants';\nimport MetricsConstants from './constants/MetricsConstants';\nimport FragmentModel from './models/FragmentModel';\nimport BufferController from './controllers/BufferController';\nimport TextBufferController from './text/TextBufferController';\nimport ScheduleController from './controllers/ScheduleController';\nimport RepresentationController from '../dash/controllers/RepresentationController';\nimport LiveEdgeFinder from './utils/LiveEdgeFinder';\nimport FactoryMaker from '../core/FactoryMaker';\nimport { checkInteger } from './utils/SupervisorTools';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport DashHandler from '../dash/DashHandler';\nimport Errors from '../core/errors/Errors';\nimport DashJSError from './vo/DashJSError';\nimport Debug from '../core/Debug';\nimport RequestModifier from './utils/RequestModifier';\nimport URLUtils from '../streaming/utils/URLUtils';\nimport BoxParser from './utils/BoxParser';\nimport FragmentRequest from './vo/FragmentRequest';\nimport { PlayListTrace } from './vo/metrics/PlayList';\n\nfunction StreamProcessor(config) {\n\n    config = config || {};\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let streamInfo = config.streamInfo;\n    let type = config.type;\n    let errHandler = config.errHandler;\n    let mimeType = config.mimeType;\n    let timelineConverter = config.timelineConverter;\n    let adapter = config.adapter;\n    let manifestModel = config.manifestModel;\n    let mediaPlayerModel = config.mediaPlayerModel;\n    let fragmentModel = config.fragmentModel;\n    let abrController = config.abrController;\n    let playbackController = config.playbackController;\n    let mediaController = config.mediaController;\n    let textController = config.textController;\n    let dashMetrics = config.dashMetrics;\n    let settings = config.settings;\n    let boxParser = config.boxParser;\n\n    let instance,\n        isDynamic,\n        mediaInfo,\n        mediaInfoArr,\n        bufferController,\n        scheduleController,\n        representationController,\n        liveEdgeFinder,\n        indexHandler,\n        streamInitialized;\n\n    function setup() {\n        resetInitialSettings();\n\n        eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, instance);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.on(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.on(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, instance);\n        eventBus.on(Events.SEEK_TARGET, onSeekTarget, instance);\n    }\n\n    function initialize(mediaSource, hasVideoTrack) {\n        indexHandler = DashHandler(context).create({\n            streamInfo: streamInfo,\n            type: type,\n            timelineConverter: timelineConverter,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            baseURLController: config.baseURLController,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors,\n            debug: Debug(context).getInstance(),\n            requestModifier: RequestModifier(context).getInstance(),\n            dashConstants: DashConstants,\n            constants: Constants,\n            urlUtils: URLUtils(context).getInstance()\n        });\n\n        // Create live edge finder for dynamic streams\n        isDynamic = streamInfo.manifestInfo.isDynamic;\n        if (isDynamic) {\n            liveEdgeFinder = LiveEdgeFinder(context).create({\n                timelineConverter: timelineConverter\n            });\n        }\n\n        // Create/initialize controllers\n        indexHandler.initialize(isDynamic);\n        abrController.registerStreamType(type, instance);\n\n        representationController = RepresentationController(context).create({\n            streamId: streamInfo.id,\n            type: type,\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            playbackController: playbackController,\n            timelineConverter: timelineConverter,\n            dashConstants: DashConstants,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors\n        });\n\n        bufferController = createBufferControllerForType(type);\n        if (bufferController) {\n            bufferController.initialize(mediaSource);\n        }\n\n        scheduleController = ScheduleController(context).create({\n            streamId: streamInfo.id,\n            type: type,\n            mimeType: mimeType,\n            adapter: adapter,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            fragmentModel: fragmentModel,\n            abrController: abrController,\n            playbackController: playbackController,\n            textController: textController,\n            mediaController: mediaController,\n            bufferController: bufferController,\n            settings: settings\n        });\n\n        if (adapter && adapter.getIsTextTrack(mimeType)) {\n            eventBus.on(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\n        }\n\n        scheduleController.initialize(hasVideoTrack);\n\n        streamInitialized = false;\n    }\n\n    function resetInitialSettings() {\n        mediaInfoArr = [];\n        mediaInfo = null;\n    }\n\n    function reset(errored, keepBuffers) {\n        if (indexHandler) {\n            indexHandler.reset();\n        }\n\n        if (bufferController) {\n            bufferController.reset(errored, keepBuffers);\n            bufferController = null;\n        }\n\n        if (scheduleController) {\n            scheduleController.reset();\n            scheduleController = null;\n        }\n\n        if (representationController) {\n            representationController.reset();\n            representationController = null;\n        }\n\n        if (liveEdgeFinder) {\n            liveEdgeFinder.reset();\n            liveEdgeFinder = null;\n        }\n\n        if (abrController) {\n            abrController.unRegisterStreamType(type);\n        }\n\n        eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, instance);\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.off(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.off(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, instance);\n        eventBus.off(Events.SEEK_TARGET, onSeekTarget, instance);\n\n        if (adapter && adapter.getIsTextTrack(mimeType)) {\n            eventBus.off(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\n        }\n\n        resetInitialSettings();\n        type = null;\n        streamInfo = null;\n    }\n\n    function isUpdating() {\n        return representationController ? representationController.isUpdating() : false;\n    }\n\n    function onStreamInitialized(e) {\n        if (!e.streamInfo || streamInfo.id !== e.streamInfo.id) return;\n\n        if (!streamInitialized) {\n            streamInitialized = true;\n            if (isDynamic) {\n                timelineConverter.setTimeSyncCompleted(true);\n                setLiveEdgeSeekTarget();\n            } else {\n                const seekTarget = playbackController.getStreamStartTime(false);\n                bufferController.setSeekStartTime(seekTarget);\n                scheduleController.setCurrentRepresentation(getRepresentationInfo());\n                scheduleController.setSeekTarget(seekTarget);\n            }\n        }\n\n        scheduleController.start();\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.sender.getType() !== getType() || e.sender.getStreamId() !== streamInfo.id) return;\n\n        if (!e.error) {\n            scheduleController.setCurrentRepresentation(adapter.convertDataToRepresentationInfo(e.currentRepresentation));\n        } else if (e.error.code !== Errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE) {\n            addDVRMetric();\n        }\n    }\n\n    function onQualityChanged(e) {\n        if (type !== e.mediaType || streamInfo.id !== e.streamInfo.id) return;\n        let representationInfo = getRepresentationInfo(e.newQuality);\n        scheduleController.setCurrentRepresentation(representationInfo);\n        dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\n        dashMetrics.createPlaylistTraceMetrics(representationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\n    }\n\n    function onBufferLevelUpdated(e) {\n        if (e.streamId !== streamInfo.id || e.mediaType !== type) return;\n\n        dashMetrics.addBufferLevel(type, new Date(), e.bufferLevel * 1000);\n\n        if (!manifestModel.getValue().doNotUpdateDVRWindowOnBufferUpdated) {\n            addDVRMetric();\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        if (e.streamId !== streamInfo.id || e.mediaType !== type) return;\n\n        dashMetrics.addBufferState(type, e.state, scheduleController.getBufferTarget());\n        if (e.state === MetricsConstants.BUFFER_EMPTY && !playbackController.isSeeking()) {\n            // logger.info('Buffer is empty! Stalling!');\n            dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REBUFFERING_REASON);\n        }\n    }\n\n    function onBufferCleared(e) {\n        if (e.streamId !== streamInfo.id || e.mediaType !== type) return;\n\n        if (e.unintended) {\n            // There was an unintended buffer remove, probably creating a gap in the buffer, remove every saved request\n            fragmentModel.removeExecutedRequestsAfterTime(e.from);\n        } else {\n            fragmentModel.syncExecutedRequestsWithBufferedRange(\n                bufferController.getBuffer().getAllBufferRanges(),\n                streamInfo.duration);\n        }\n    }\n\n    function addDVRMetric() {\n        const manifestInfo = streamInfo.manifestInfo;\n        const isDynamic = manifestInfo.isDynamic;\n        const range = timelineConverter.calcSegmentAvailabilityRange(representationController.getCurrentRepresentation(), isDynamic);\n        dashMetrics.addDVRInfo(getType(), playbackController.getTime(), manifestInfo, range);\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getRepresentationController() {\n        return representationController;\n    }\n\n    function getBuffer() {\n        return bufferController ? bufferController.getBuffer() : null;\n    }\n\n    function setBuffer(buffer) {\n        bufferController.setBuffer(buffer);\n    }\n\n    function getBufferController() {\n        return bufferController;\n    }\n\n    function getFragmentModel() {\n        return fragmentModel;\n    }\n\n    function updateStreamInfo(newStreamInfo) {\n        streamInfo = newStreamInfo;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function selectMediaInfo(newMediaInfo) {\n        if (newMediaInfo !== mediaInfo && (!newMediaInfo || !mediaInfo || (newMediaInfo.type === mediaInfo.type))) {\n            mediaInfo = newMediaInfo;\n        }\n\n        const newRealAdaptation = adapter.getRealAdaptation(streamInfo, mediaInfo);\n        const voRepresentations = adapter.getVoRepresentations(mediaInfo);\n\n        if (representationController) {\n            const realAdaptation = representationController.getData();\n            const maxQuality = abrController.getTopQualityIndexFor(type, streamInfo.id);\n            const minIdx = abrController.getMinAllowedIndexFor(type);\n\n            let quality,\n                averageThroughput;\n            let bitrate = null;\n\n            if ((realAdaptation === null || (realAdaptation.id != newRealAdaptation.id)) && type !== Constants.FRAGMENTED_TEXT) {\n                averageThroughput = abrController.getThroughputHistory().getAverageThroughput(type);\n                bitrate = averageThroughput || abrController.getInitialBitrateFor(type);\n                quality = abrController.getQualityForBitrate(mediaInfo, bitrate);\n            } else {\n                quality = abrController.getQualityFor(type);\n            }\n\n            if (minIdx !== undefined && quality < minIdx) {\n                quality = minIdx;\n            }\n            if (quality > maxQuality) {\n                quality = maxQuality;\n            }\n            indexHandler.setMimeType(mediaInfo ? mediaInfo.mimeType : null);\n            representationController.updateData(newRealAdaptation, voRepresentations, type, quality);\n        }\n    }\n\n    function addMediaInfo(newMediaInfo, selectNewMediaInfo) {\n        if (mediaInfoArr.indexOf(newMediaInfo) === -1) {\n            mediaInfoArr.push(newMediaInfo);\n        }\n\n        if (selectNewMediaInfo) {\n            this.selectMediaInfo(newMediaInfo);\n        }\n    }\n\n    function getMediaInfoArr() {\n        return mediaInfoArr;\n    }\n\n    function getMediaInfo() {\n        return mediaInfo;\n    }\n\n    function getMediaSource() {\n        return bufferController.getMediaSource();\n    }\n\n    function setMediaSource(mediaSource) {\n        bufferController.setMediaSource(mediaSource, getMediaInfoArr());\n    }\n\n    function dischargePreBuffer() {\n        bufferController.dischargePreBuffer();\n    }\n\n    function getScheduleController() {\n        return scheduleController;\n    }\n\n    /**\n     * Get a specific voRepresentation. If quality parameter is defined, this function will return the voRepresentation for this quality.\n     * Otherwise, this function will return the current voRepresentation used by the representationController.\n     * @param {number} quality - quality index of the voRepresentaion expected.\n     */\n    function getRepresentationInfo(quality) {\n        let voRepresentation;\n\n        if (quality !== undefined) {\n            checkInteger(quality);\n            voRepresentation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n        } else {\n            voRepresentation = representationController ? representationController.getCurrentRepresentation() : null;\n        }\n\n        return adapter.convertDataToRepresentationInfo(voRepresentation);\n    }\n\n    function isBufferingCompleted() {\n        return bufferController ? bufferController.getIsBufferingCompleted() : false;\n    }\n\n    function getBufferLevel() {\n        return bufferController ? bufferController.getBufferLevel() : 0;\n    }\n\n    function onInitFragmentNeeded(e) {\n        if (!e.sender || e.sender.getType() !== type || e.sender.getStreamId() !== streamInfo.id) return;\n\n        if (bufferController && e.representationId) {\n            if (!bufferController.appendInitSegment(e.representationId)) {\n                // Init segment not in cache, send new request\n                const request = indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation()) : null;\n                scheduleController.processInitRequest(request);\n            }\n        }\n    }\n\n    function onMediaFragmentNeeded(e) {\n        if (e.sender.getType() !== type || e.sender.getStreamId() !== streamInfo.id) return;\n\n        let request;\n\n        // Don't schedule next fragments while pruning to avoid buffer inconsistencies\n        if (!bufferController.getIsPruningInProgress()) {\n            request = findNextRequest(e.seekTarget, e.replacement);\n            scheduleController.setSeekTarget(NaN);\n            if (request && !e.replacement) {\n                if (!isNaN(request.startTime + request.duration)) {\n                    setIndexHandlerTime(request.startTime + request.duration);\n                }\n                request.delayLoadingTime = new Date().getTime() + scheduleController.getTimeToLoadDelay();\n                scheduleController.setTimeToLoadDelay(0);\n            }\n        }\n\n        scheduleController.processMediaRequest(request);\n    }\n\n    function findNextRequest(seekTarget, requestToReplace) {\n        const representationInfo = getRepresentationInfo();\n        const hasSeekTarget = !isNaN(seekTarget);\n        const currentTime = playbackController.getNormalizedTime();\n        let time = hasSeekTarget ? seekTarget : getIndexHandlerTime();\n        let bufferIsDivided = false;\n        let request;\n\n        if (isNaN(time) || (getType() === Constants.FRAGMENTED_TEXT && !textController.isTextEnabled())) {\n            return null;\n        }\n        /**\n         * This is critical for IE/Safari/EDGE\n         * */\n        if (bufferController) {\n            let range = bufferController.getRangeAt(time);\n            const playingRange = bufferController.getRangeAt(currentTime);\n            if ((range !== null || playingRange !== null) && !hasSeekTarget) {\n                if (!range || (playingRange && playingRange.start != range.start && playingRange.end != range.end)) {\n                    const hasDiscontinuities = bufferController.getBuffer().hasDiscontinuitiesAfter(currentTime);\n                    if (hasDiscontinuities && getType() !== Constants.FRAGMENTED_TEXT) {\n                        fragmentModel.removeExecutedRequestsAfterTime(playingRange.end);\n                        bufferIsDivided = true;\n                    }\n                }\n            }\n        }\n\n        if (requestToReplace) {\n            time = requestToReplace.startTime + (requestToReplace.duration / 2);\n            request = getFragmentRequest(representationInfo, time, {\n                timeThreshold: 0,\n                ignoreIsFinished: true\n            });\n        } else {\n            // Use time just whenever is strictly needed\n            request = getFragmentRequest(representationInfo,\n                hasSeekTarget || bufferIsDivided ? time : undefined, {\n                keepIdx: !hasSeekTarget && !bufferIsDivided\n            });\n\n            // Then, check if this request was downloaded or not\n            while (request && request.action !== FragmentRequest.ACTION_COMPLETE && fragmentModel.isFragmentLoaded(request)) {\n                // loop until we found not loaded fragment, or no fragment\n                request = getFragmentRequest(representationInfo);\n            }\n        }\n\n        return request;\n    }\n\n    function onTimedTextRequested(e) {\n        if (e.streamId !== streamInfo.id) return;\n\n        //if subtitles are disabled, do not download subtitles file.\n        if (textController.isTextEnabled()) {\n            const representation = representationController ? representationController.getRepresentationForQuality(e.index) : null;\n            const request = indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null;\n            scheduleController.processInitRequest(request);\n        }\n    }\n\n    function onMediaFragmentLoaded(e) {\n        const chunk = e.chunk;\n        if (chunk.streamId !== streamInfo.id || chunk.mediaInfo.type != type) return;\n\n        const bytes = chunk.bytes;\n        const quality = chunk.quality;\n        const currentRepresentation = getRepresentationInfo(quality);\n\n        // Update current representation info (to update fragmentDuration for example in case of SegmentTimeline)\n        scheduleController.setCurrentRepresentation(currentRepresentation);\n\n        const voRepresentation = representationController && currentRepresentation ? representationController.getRepresentationForQuality(currentRepresentation.quality) : null;\n        const eventStreamMedia = adapter.getEventsFor(currentRepresentation.mediaInfo);\n        const eventStreamTrack = adapter.getEventsFor(currentRepresentation, voRepresentation);\n\n        if (eventStreamMedia && eventStreamMedia.length > 0 || eventStreamTrack && eventStreamTrack.length > 0) {\n            const request = fragmentModel.getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                quality: quality,\n                index: chunk.index\n            })[0];\n\n            const events = handleInbandEvents(bytes, request, eventStreamMedia, eventStreamTrack);\n            eventBus.trigger(Events.ADD_INBAND_EVENTS_REQUESTED, { sender: instance, events: events });\n        }\n    }\n\n    function handleInbandEvents(data, request, mediaInbandEvents, trackInbandEvents) {\n        const fragmentStartTime = Math.max(!request || isNaN(request.startTime) ? 0 : request.startTime, 0);\n        const eventStreams = [];\n        const events = [];\n\n        /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */\n        const inbandEvents = mediaInbandEvents.concat(trackInbandEvents);\n        for (let i = 0, ln = inbandEvents.length; i < ln; i++) {\n            eventStreams[inbandEvents[i].schemeIdUri + '/' + inbandEvents[i].value] = inbandEvents[i];\n        }\n\n        const isoFile = BoxParser(context).getInstance().parse(data);\n        const eventBoxes = isoFile.getBoxes('emsg');\n\n        for (let i = 0, ln = eventBoxes.length; i < ln; i++) {\n            const event = adapter.getEvent(eventBoxes[i], eventStreams, fragmentStartTime);\n\n            if (event) {\n                events.push(event);\n            }\n        }\n\n        return events;\n    }\n\n    function createBuffer(previousBuffers) {\n        return (getBuffer() || bufferController ? bufferController.createBuffer(mediaInfoArr, previousBuffers) : null);\n    }\n\n    function switchTrackAsked() {\n        scheduleController.switchTrackAsked();\n    }\n\n    function createBufferControllerForType(type) {\n        let controller = null;\n\n        if (!type) {\n            errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + 'not properly defined'));\n            return null;\n        }\n\n        if (type === Constants.VIDEO || type === Constants.AUDIO) {\n            controller = BufferController(context).create({\n                streamInfo: streamInfo,\n                type: type,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                fragmentModel: fragmentModel,\n                errHandler: errHandler,\n                mediaController: mediaController,\n                representationController: representationController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                settings: settings\n            });\n        } else {\n            controller = TextBufferController(context).create({\n                streamInfo: streamInfo,\n                type: type,\n                mimeType: mimeType,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                fragmentModel: fragmentModel,\n                errHandler: errHandler,\n                mediaController: mediaController,\n                representationController: representationController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                settings: settings\n            });\n        }\n\n        return controller;\n    }\n\n    function setLiveEdgeSeekTarget() {\n        if (!liveEdgeFinder) return;\n\n        const currentRepresentationInfo = getRepresentationInfo();\n        const liveEdge = liveEdgeFinder.getLiveEdge(currentRepresentationInfo);\n        const startTime = liveEdge - playbackController.computeLiveDelay(currentRepresentationInfo.fragmentDuration, currentRepresentationInfo.mediaInfo.streamInfo.manifestInfo.DVRWindowSize);\n        const request = getFragmentRequest(currentRepresentationInfo, startTime, {\n            ignoreIsFinished: true\n        });\n\n        if (request) {\n            // When low latency mode is selected but browser doesn't support fetch\n            // start at the beginning of the segment to avoid consuming the whole buffer\n            if (settings.get().streaming.lowLatencyEnabled) {\n                const liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\n                playbackController.setLiveStartTime(liveStartTime);\n            } else {\n                playbackController.setLiveStartTime(request.startTime);\n            }\n        }\n\n        const seekTarget = playbackController.getStreamStartTime(false, liveEdge);\n        bufferController.setSeekStartTime(seekTarget);\n        scheduleController.setCurrentRepresentation(currentRepresentationInfo);\n        scheduleController.setSeekTarget(seekTarget);\n        scheduleController.start();\n\n        // For multi periods stream, if the startTime is beyond current period then seek to corresponding period (see StreamController::onPlaybackSeeking)\n        if (seekTarget > (currentRepresentationInfo.mediaInfo.streamInfo.start + currentRepresentationInfo.mediaInfo.streamInfo.duration)) {\n            playbackController.seek(seekTarget);\n        }\n\n        dashMetrics.updateManifestUpdateInfo({\n            currentTime: seekTarget,\n            presentationStartTime: liveEdge,\n            latency: liveEdge - seekTarget,\n            clientTimeOffset: timelineConverter.getClientTimeOffset()\n        });\n    }\n\n    function onSeekTarget(e) {\n        if (e.mediaType !== type || e.streamId !== streamInfo.id) return;\n\n        setIndexHandlerTime(e.time);\n        scheduleController.setSeekTarget(e.time);\n    }\n\n    function setIndexHandlerTime(value) {\n        if (indexHandler) {\n            indexHandler.setCurrentTime(value);\n        }\n    }\n\n    function getIndexHandlerTime() {\n        return indexHandler ? indexHandler.getCurrentTime() : NaN;\n    }\n\n    function resetIndexHandler() {\n        if (indexHandler) {\n            indexHandler.resetIndex();\n        }\n    }\n\n    function getInitRequest(quality) {\n        checkInteger(quality);\n        const representation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n        return indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null;\n    }\n\n    function getFragmentRequest(representationInfo, time, options) {\n        let fragRequest = null;\n\n        if (indexHandler) {\n            const representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null;\n\n            // if time and options are undefined, it means the next segment is requested\n            // otherwise, the segment at this specific time is requested.\n            if (time !== undefined && options !== undefined) {\n                fragRequest = indexHandler.getSegmentRequestForTime(getMediaInfo(), representation, time, options);\n            } else {\n                fragRequest = indexHandler.getNextSegmentRequest(getMediaInfo(), representation);\n            }\n        }\n\n        return fragRequest;\n    }\n\n    function finalisePlayList(time, reason) {\n        dashMetrics.pushPlayListTraceMetrics(time, reason);\n    }\n\n    instance = {\n        initialize: initialize,\n        isUpdating: isUpdating,\n        getType: getType,\n        getBufferController: getBufferController,\n        getFragmentModel: getFragmentModel,\n        getScheduleController: getScheduleController,\n        getRepresentationController: getRepresentationController,\n        getRepresentationInfo: getRepresentationInfo,\n        getBufferLevel: getBufferLevel,\n        isBufferingCompleted: isBufferingCompleted,\n        createBuffer: createBuffer,\n        updateStreamInfo: updateStreamInfo,\n        getStreamInfo: getStreamInfo,\n        selectMediaInfo: selectMediaInfo,\n        addMediaInfo: addMediaInfo,\n        switchTrackAsked: switchTrackAsked,\n        getMediaInfoArr: getMediaInfoArr,\n        getMediaInfo: getMediaInfo,\n        getMediaSource: getMediaSource,\n        setMediaSource: setMediaSource,\n        dischargePreBuffer: dischargePreBuffer,\n        getBuffer: getBuffer,\n        setBuffer: setBuffer,\n        setIndexHandlerTime: setIndexHandlerTime,\n        getIndexHandlerTime: getIndexHandlerTime,\n        resetIndexHandler: resetIndexHandler,\n        getInitRequest: getInitRequest,\n        getFragmentRequest: getFragmentRequest,\n        finalisePlayList: finalisePlayList,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\nStreamProcessor.__dashjs_factory_name = 'StreamProcessor';\nexport default FactoryMaker.getClassFactory(StreamProcessor);\n"]}