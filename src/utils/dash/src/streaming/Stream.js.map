{"version":3,"sources":["../../../../src/streaming/Stream.js"],"names":["Stream","config","context","eventBus","getInstance","urlUtils","manifestModel","mediaPlayerModel","manifestUpdater","adapter","capabilities","errHandler","timelineConverter","dashMetrics","abrController","playbackController","eventController","mediaController","textController","videoModel","settings","instance","logger","streamProcessors","isStreamActivated","isMediaInitialized","streamInfo","hasVideoTrack","hasAudioTrack","updateError","isUpdating","protectionController","fragmentController","thumbnailController","preloaded","boxParser","debug","trackChangedEvent","codecCompatibilityTable","setup","getLogger","resetInitialSettings","create","dashConstants","DashConstants","registerEvents","on","Events","BUFFERING_COMPLETED","onBufferingCompleted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","INBAND_EVENTS","onInbandEvents","unRegisterEvents","off","registerProtectionEvents","KEY_ERROR","onProtectionError","SERVER_CERTIFICATE_UPDATED","LICENSE_REQUEST_COMPLETE","KEY_SYSTEM_SELECTED","KEY_SESSION_CREATED","KEY_STATUSES_CHANGED","unRegisterProtectionEvents","initialize","StreamInfo","ProtectionController","activate","mediaSource","previousBuffers","result","CURRENT_TRACK_CHANGED","onCurrentTrackChanged","getPreloaded","initializeMedia","initializeAfterPreload","deactivate","keepBuffers","ln","length","errored","i","fragmentModel","getFragmentModel","removeExecutedRequestsBeforeTime","getStartTime","getDuration","reset","setPreloaded","isActive","setMediaSource","isMediaSupported","getMediaInfo","splice","dischargePreBuffer","msg","error","DashJSError","Errors","MANIFEST_ERROR_ID_NOSTREAMS_CODE","getValue","fatal","pause","duration","NaN","start","getId","id","getStreamInfo","getHasAudioTrack","getHasVideoTrack","getThumbnailController","checkConfig","hasOwnProperty","Error","Constants","MISSING_CONFIG_ERROR","getBitrateListFor","type","IMAGE","getBitrateList","mediaInfo","event","message","codec","MUXED","MANIFEST_ERROR_ID_MULTIPLEXED_CODE","TEXT","FRAGMENTED_TEXT","EMBEDDED_TEXT","contentProtection","supportsEncryptedMedia","CAPABILITY_MEDIAKEYS_ERROR_CODE","CAPABILITY_MEDIAKEYS_ERROR_MESSAGE","supportsCodec","e","newMediaInfo","manifest","setCurrentMediaInfo","processor","getProcessorForMediaInfo","currentTime","getTime","info","refreshManifestOnSwitchTrack","refreshManifest","selectMediaInfo","updateTopQualityIndex","switchTrackAsked","abortRequests","getScheduleController","setSeekTarget","setIndexHandlerTime","resetIndexHandler","createStreamProcessor","allMediaForType","optionalSettings","getModel","streamProcessor","mimeType","baseURLController","setBuffer","buffer","replaceIdx","push","ignoreMediaInfo","idx","index","addMediaInfo","initializeMediaForType","getAllMediaInfoForType","initialMediaInfo","VIDEO","AUDIO","addEmbeddedTrack","addTrack","getTracksFor","events","getTextDefaultEnabled","checkInitialMediaSettingsForType","getCurrentTrackFor","trigger","STREAM_INITIALIZING","addInlineEvents","getEventsFor","addInbandEvents","element","getElement","filterCodecs","test","nodeName","buffers","createBuffers","checkIfInitializationCompleted","realAdaptation","getAdaptationForType","Array","isArray","Representation_asArray","filter","_","getCodec","hasError","audio","video","DATA_UPDATE_FAILED_ERROR_CODE","DATA_UPDATE_FAILED_ERROR_MESSAGE","getType","initializeForMedia","STREAM_INITIALIZED","createBuffer","getBuffer","streamId","processors","getProcessors","warn","isBufferingCompleted","STREAM_BUFFERING_COMPLETED","sender","getStreamId","arr","updateData","updatedStreamInfo","updateStreamInfo","getMediaInfoForType","oldMediaInfo","undefined","isMediaCodecCompatible","newStream","compareCodecs","isProtectionCompatible","stream","compareProtectionConfig","newStreamInfo","currentStreamInfo","newAdaptation","currentAdaptation","ContentProtection","sameMimeType","oldCodecs","map","representation","codecs","newCodecs","codecMatch","some","newCodec","indexOf","partialCodecMatch","oldCodec","codecRootCompatibleWithCodec","codec1","codec2","codecRoot","split","rootCompatible","compatTableCodec","compatibleCodecs","compatibleCodec","value","preload","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"Stream.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport DashConstants from '../dash/constants/DashConstants';\nimport StreamProcessor from './StreamProcessor';\nimport FragmentController from './controllers/FragmentController';\nimport ThumbnailController from './thumbnail/ThumbnailController';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport Debug from '../core/Debug';\nimport Errors from '../core/errors/Errors';\nimport FactoryMaker from '../core/FactoryMaker';\nimport DashJSError from './vo/DashJSError';\nimport BoxParser from './utils/BoxParser';\nimport URLUtils from './utils/URLUtils';\n\nfunction Stream(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    const manifestModel = config.manifestModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const manifestUpdater = config.manifestUpdater;\n    const adapter = config.adapter;\n    const capabilities = config.capabilities;\n    const errHandler = config.errHandler;\n    const timelineConverter = config.timelineConverter;\n    const dashMetrics = config.dashMetrics;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const eventController = config.eventController;\n    const mediaController = config.mediaController;\n    const textController = config.textController;\n    const videoModel = config.videoModel;\n    const settings = config.settings;\n\n    let instance,\n        logger,\n        streamProcessors,\n        isStreamActivated,\n        isMediaInitialized,\n        streamInfo,\n        hasVideoTrack,\n        hasAudioTrack,\n        updateError,\n        isUpdating,\n        protectionController,\n        fragmentController,\n        thumbnailController,\n        preloaded,\n        boxParser,\n        debug,\n        trackChangedEvent;\n\n    const codecCompatibilityTable = [\n        {\n            'codec': 'avc1',\n            'compatibleCodecs': ['avc3']\n        },\n        {\n            'codec': 'avc3',\n            'compatibleCodecs': ['avc1']\n        }\n    ];\n\n    function setup() {\n        debug = Debug(context).getInstance();\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n\n        boxParser = BoxParser(context).getInstance();\n\n        fragmentController = FragmentController(context).create({\n            mediaPlayerModel: mediaPlayerModel,\n            dashMetrics: dashMetrics,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser,\n            dashConstants: DashConstants,\n            urlUtils: urlUtils\n        });\n\n        registerEvents();\n    }\n\n    function registerEvents() {\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.on(Events.INBAND_EVENTS, onInbandEvents, instance);\n    }\n\n    function unRegisterEvents() {\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.off(Events.INBAND_EVENTS, onInbandEvents, instance);\n    }\n\n    function registerProtectionEvents() {\n        if (protectionController) {\n            eventBus.on(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function unRegisterProtectionEvents() {\n        if (protectionController) {\n            eventBus.off(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function initialize(StreamInfo, ProtectionController) {\n        streamInfo = StreamInfo;\n        protectionController = ProtectionController;\n        registerProtectionEvents();\n    }\n\n    /**\n     * Activates Stream by re-initializing some of its components\n     * @param {MediaSource} mediaSource\n     * @memberof Stream#\n     * @param {SourceBuffer} previousBuffers\n     */\n    function activate(mediaSource, previousBuffers) {\n        if (!isStreamActivated) {\n            let result;\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n            if (!getPreloaded()) {\n                result = initializeMedia(mediaSource, previousBuffers);\n            } else {\n                initializeAfterPreload();\n                result = previousBuffers;\n            }\n            isStreamActivated = true;\n            return result;\n        }\n        return previousBuffers;\n    }\n\n    /**\n     * Partially resets some of the Stream elements\n     * @memberof Stream#\n     * @param {boolean} keepBuffers\n     */\n    function deactivate(keepBuffers) {\n        let ln = streamProcessors ? streamProcessors.length : 0;\n        const errored = false;\n        for (let i = 0; i < ln; i++) {\n            let fragmentModel = streamProcessors[i].getFragmentModel();\n            fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n            streamProcessors[i].reset(errored, keepBuffers);\n        }\n        streamProcessors = [];\n        isStreamActivated = false;\n        isMediaInitialized = false;\n        setPreloaded(false);\n        eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n    }\n\n    function isActive() {\n        return isStreamActivated;\n    }\n\n    function setMediaSource(mediaSource) {\n        for (let i = 0; i < streamProcessors.length;) {\n            if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\n                streamProcessors[i].setMediaSource(mediaSource);\n                i++;\n            } else {\n                streamProcessors[i].reset();\n                streamProcessors.splice(i, 1);\n            }\n        }\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\n            //so do this after the buffers are created above.\n            streamProcessors[i].dischargePreBuffer();\n        }\n\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg + 'nostreams', manifestModel.getValue()));\n            logger.fatal(msg);\n        }\n    }\n\n    function resetInitialSettings() {\n        deactivate();\n        streamInfo = null;\n        hasVideoTrack = false;\n        hasAudioTrack = false;\n        updateError = {};\n        isUpdating = false;\n    }\n\n    function reset() {\n\n        if (playbackController) {\n            playbackController.pause();\n        }\n\n        if (fragmentController) {\n            fragmentController.reset();\n            fragmentController = null;\n        }\n\n        resetInitialSettings();\n\n        unRegisterEvents();\n\n        unRegisterProtectionEvents();\n\n        setPreloaded(false);\n    }\n\n    function getDuration() {\n        return streamInfo ? streamInfo.duration : NaN;\n    }\n\n    function getStartTime() {\n        return streamInfo ? streamInfo.start : NaN;\n    }\n\n    function getId() {\n        return streamInfo ? streamInfo.id : null;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function getHasAudioTrack () {\n        return hasAudioTrack;\n    }\n\n    function getHasVideoTrack () {\n        return hasVideoTrack;\n    }\n\n    function getThumbnailController() {\n        return thumbnailController;\n    }\n\n    function checkConfig() {\n        if (!videoModel || !abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @returns {Array}\n     * @memberof Stream#\n     */\n    function getBitrateListFor(type) {\n        checkConfig();\n        if (type === Constants.IMAGE) {\n            if (!thumbnailController) {\n                return [];\n            }\n            return thumbnailController.getBitrateList();\n        }\n        const mediaInfo = getMediaInfo(type);\n        return abrController.getBitrateList(mediaInfo);\n    }\n\n    function onProtectionError(event) {\n        if (event.error) {\n            errHandler.error(event.error);\n            logger.fatal(event.error.message);\n            reset();\n        }\n    }\n\n    function isMediaSupported(mediaInfo) {\n        const type = mediaInfo ? mediaInfo.type : null;\n        let codec,\n            msg;\n\n        if (type === Constants.MUXED) {\n            msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\n            logger.fatal(msg);\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue()));\n            return false;\n        }\n\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) {\n            return true;\n        }\n        codec = mediaInfo.codec;\n        logger.debug(type + ' codec: ' + codec);\n\n        if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\n            errHandler.error(new DashJSError(Errors.CAPABILITY_MEDIAKEYS_ERROR_CODE, Errors.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE));\n        } else if (!capabilities.supportsCodec(codec)) {\n            msg = type + 'Codec (' + codec + ') is not supported.';\n            logger.error(msg);\n            return false;\n        }\n\n        return true;\n    }\n\n    function onCurrentTrackChanged(e) {\n        if (!streamInfo || e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\n        let mediaInfo = e.newMediaInfo;\n        let manifest = manifestModel.getValue();\n\n        adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo);\n\n        let processor = getProcessorForMediaInfo(mediaInfo);\n        if (!processor) return;\n\n        let currentTime = playbackController.getTime();\n        logger.info('Stream -  Process track changed at current time ' + currentTime);\n\n        logger.debug('Stream -  Update stream controller');\n        if (manifest.refreshManifestOnSwitchTrack) { // Applies only for MSS streams\n            logger.debug('Stream -  Refreshing manifest for switch track');\n            trackChangedEvent = e;\n            manifestUpdater.refreshManifest();\n        } else {\n            processor.selectMediaInfo(mediaInfo);\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\n                abrController.updateTopQualityIndex(mediaInfo);\n                processor.switchTrackAsked();\n                processor.getFragmentModel().abortRequests();\n            } else {\n                processor.getScheduleController().setSeekTarget(currentTime);\n                processor.setIndexHandlerTime(currentTime);\n                processor.resetIndexHandler();\n            }\n        }\n    }\n\n    function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\n\n        let fragmentModel = fragmentController.getModel(getId(),  mediaInfo ? mediaInfo.type : null);\n\n        let streamProcessor = StreamProcessor(context).create({\n            streamInfo: streamInfo,\n            type: mediaInfo ? mediaInfo.type : null,\n            mimeType: mediaInfo ? mediaInfo.mimeType : null,\n            timelineConverter: timelineConverter,\n            adapter: adapter,\n            manifestModel: manifestModel,\n            mediaPlayerModel: mediaPlayerModel,\n            fragmentModel: fragmentModel,\n            dashMetrics: config.dashMetrics,\n            baseURLController: config.baseURLController,\n            abrController: abrController,\n            playbackController: playbackController,\n            mediaController: mediaController,\n            textController: textController,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser\n        });\n\n        streamProcessor.initialize(mediaSource, hasVideoTrack);\n        abrController.updateTopQualityIndex(mediaInfo);\n\n        if (optionalSettings) {\n            streamProcessor.setBuffer(optionalSettings.buffer);\n            streamProcessor.setIndexHandlerTime(optionalSettings.currentTime);\n            streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\n        } else {\n            streamProcessors.push(streamProcessor);\n        }\n\n        if (optionalSettings && optionalSettings.ignoreMediaInfo) {\n            return;\n        }\n\n        if (mediaInfo && (mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) {\n            let idx;\n            for (let i = 0; i < allMediaForType.length; i++) {\n                if (allMediaForType[i].index === mediaInfo.index) {\n                    idx = i;\n                }\n                streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\n            }\n            streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\n        } else {\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n    }\n\n    function initializeMediaForType(type, mediaSource) {\n        const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\n\n        let mediaInfo = null;\n        let initialMediaInfo;\n\n        if (!allMediaForType || allMediaForType.length === 0) {\n            logger.info('No ' + type + ' data.');\n            return;\n        }\n\n        if (type === Constants.VIDEO) {\n            hasVideoTrack = true;\n        }\n\n        if (type === Constants.AUDIO) {\n            hasAudioTrack = true;\n        }\n\n        for (let i = 0, ln = allMediaForType.length; i < ln; i++) {\n            mediaInfo = allMediaForType[i];\n\n            if (type === Constants.EMBEDDED_TEXT) {\n                textController.addEmbeddedTrack(mediaInfo);\n            } else {\n                if (!isMediaSupported(mediaInfo)) continue;\n                mediaController.addTrack(mediaInfo);\n            }\n        }\n\n        if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\n            return;\n        }\n\n        if (type === Constants.IMAGE) {\n            thumbnailController = ThumbnailController(context).create({\n                streamInfo: streamInfo,\n                adapter: adapter,\n                baseURLController: config.baseURLController,\n                timelineConverter: config.timelineConverter,\n                debug: debug,\n                eventBus: eventBus,\n                events: Events,\n                dashConstants: DashConstants\n            });\n            return;\n        }\n\n        if (type !== Constants.FRAGMENTED_TEXT || (type === Constants.FRAGMENTED_TEXT && textController.getTextDefaultEnabled())) {\n            mediaController.checkInitialMediaSettingsForType(type, streamInfo);\n            initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\n        }\n\n        if (type === Constants.FRAGMENTED_TEXT && !textController.getTextDefaultEnabled()) {\n            initialMediaInfo = mediaController.getTracksFor(type, streamInfo)[0];\n        }\n\n        eventBus.trigger(Events.STREAM_INITIALIZING, {\n            streamInfo: streamInfo,\n            mediaInfo: mediaInfo\n        });\n\n        // TODO : How to tell index handler live/duration?\n        // TODO : Pass to controller and then pass to each method on handler?\n\n        createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\n    }\n\n    function addInlineEvents() {\n        if (eventController) {\n            const events = adapter.getEventsFor(streamInfo);\n            eventController.addInlineEvents(events);\n        }\n    }\n\n    function addInbandEvents(events) {\n        if (eventController) {\n            eventController.addInbandEvents(events);\n        }\n    }\n\n    function initializeMedia(mediaSource, previousBuffers) {\n        checkConfig();\n        let element = videoModel.getElement();\n\n        addInlineEvents();\n\n        isUpdating = true;\n\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        if (!element || (element && (/^VIDEO$/i).test(element.nodeName))) {\n            initializeMediaForType(Constants.VIDEO, mediaSource);\n        }\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\n        const buffers = createBuffers(previousBuffers);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n            logger.fatal(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n\n        return buffers;\n    }\n\n    function initializeAfterPreload() {\n        isUpdating = true;\n        checkConfig();\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n            logger.debug(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n    }\n\n    function filterCodecs(type) {\n        const realAdaptation = adapter.getAdaptationForType(streamInfo ? streamInfo.index : null, type, streamInfo);\n\n        if (!realAdaptation || !Array.isArray(realAdaptation.Representation_asArray)) return;\n\n        // Filter codecs that are not supported\n        realAdaptation.Representation_asArray = realAdaptation.Representation_asArray.filter((_, i) => {\n            // keep at least codec from lowest representation\n            if (i === 0) return true;\n\n            const codec = adapter.getCodec(realAdaptation, i, true);\n            if (!capabilities.supportsCodec(codec)) {\n                logger.error('[Stream] codec not supported: ' + codec);\n                return false;\n            }\n            return true;\n        });\n    }\n\n    function checkIfInitializationCompleted() {\n        const ln = streamProcessors.length;\n        const hasError = !!updateError.audio || !!updateError.video;\n        let error = hasError ? new DashJSError(Errors.DATA_UPDATE_FAILED_ERROR_CODE, Errors.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null;\n\n        for (let i = 0; i < ln; i++) {\n            if (streamProcessors[i].isUpdating() || isUpdating) {\n                return;\n            }\n        }\n\n        if (!isMediaInitialized) {\n            return;\n        }\n\n        if (protectionController) {\n            // Need to check if streamProcessors exists because streamProcessors\n            // could be cleared in case an error is detected while initializing DRM keysystem\n            for (let i = 0; i < ln && streamProcessors[i]; i++) {\n                if (streamProcessors[i].getType() === Constants.AUDIO ||\n                    streamProcessors[i].getType() === Constants.VIDEO ||\n                    streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) {\n                    protectionController.initializeForMedia(streamProcessors[i].getMediaInfo());\n                }\n            }\n        }\n\n        if (error) {\n            errHandler.error(error);\n        } else {\n            eventBus.trigger(Events.STREAM_INITIALIZED, { streamInfo: streamInfo });\n        }\n    }\n\n    function getMediaInfo(type) {\n        let streamProcessor = null;\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            streamProcessor = streamProcessors[i];\n\n            if (streamProcessor.getType() === type) {\n                return streamProcessor.getMediaInfo();\n            }\n        }\n\n        return null;\n    }\n\n    function createBuffers(previousBuffers) {\n        const buffers = {};\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            const buffer = streamProcessors[i].createBuffer(previousBuffers);\n            if (buffer) {\n                buffers[streamProcessors[i].getType()] = buffer.getBuffer();\n            }\n        }\n        return buffers;\n    }\n\n    function onBufferingCompleted(e) {\n        if (e.streamId !== streamInfo.id) return;\n\n        let processors = getProcessors();\n        const ln = processors.length;\n\n        if (ln === 0) {\n            logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\n            return;\n        }\n\n        // if there is at least one buffer controller that has not completed buffering yet do nothing\n        for (let i = 0; i < ln; i++) {\n            //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\n            if (!processors[i].isBufferingCompleted() && (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) {\n                logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed');\n                return;\n            }\n        }\n\n        logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\n        eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, {\n            streamInfo: streamInfo\n        });\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (!streamInfo || e.sender.getStreamId() !== streamInfo.id) return;\n\n        updateError[e.sender.getType()] = e.error;\n        checkIfInitializationCompleted();\n    }\n\n    function onInbandEvents(e) {\n        if (!streamInfo || e.streamInfo.id !== streamInfo.id) return;\n        addInbandEvents(e.events);\n    }\n\n    function getProcessorForMediaInfo(mediaInfo) {\n        if (!mediaInfo) {\n            return null;\n        }\n\n        let processors = getProcessors();\n\n        return processors.filter(function (processor) {\n            return (processor.getType() === mediaInfo.type);\n        })[0];\n    }\n\n    function getProcessors() {\n        let arr = [];\n\n        let type,\n            streamProcessor;\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            streamProcessor = streamProcessors[i];\n            type = streamProcessor.getType();\n\n            if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) {\n                arr.push(streamProcessor);\n            }\n        }\n\n        return arr;\n    }\n\n    function updateData(updatedStreamInfo) {\n        logger.info('Manifest updated... updating data system wide.');\n\n        isStreamActivated = false;\n        isUpdating = true;\n        streamInfo = updatedStreamInfo;\n\n        if (eventController) {\n            addInlineEvents();\n        }\n\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            let streamProcessor = streamProcessors[i];\n            streamProcessor.updateStreamInfo(streamInfo);\n            let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType());\n            abrController.updateTopQualityIndex(mediaInfo);\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n\n        if (trackChangedEvent) {\n            let mediaInfo = trackChangedEvent.newMediaInfo;\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\n                let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\n                if (!processor) return;\n                processor.switchTrackAsked();\n                trackChangedEvent = undefined;\n            }\n        }\n\n        isUpdating = false;\n        checkIfInitializationCompleted();\n    }\n\n    function isMediaCodecCompatible(newStream) {\n        return compareCodecs(newStream, Constants.VIDEO) && compareCodecs(newStream, Constants.AUDIO);\n    }\n\n    function isProtectionCompatible(stream) {\n        return compareProtectionConfig(stream, Constants.VIDEO) && compareProtectionConfig(stream, Constants.AUDIO);\n    }\n\n    function compareProtectionConfig(stream, type) {\n        if (!stream) {\n            return false;\n        }\n        const newStreamInfo = stream.getStreamInfo();\n        const currentStreamInfo = getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        // If any of the periods requires EME, we can't do smooth transition\n        if (newAdaptation.ContentProtection || currentAdaptation.ContentProtection) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function compareCodecs(newStream, type) {\n        if (!newStream || !newStream.hasOwnProperty('getStreamInfo')) {\n            return false;\n        }\n        const newStreamInfo = newStream.getStreamInfo();\n        const currentStreamInfo = getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        const sameMimeType = newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\n        const oldCodecs = currentAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const newCodecs = newAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const codecMatch = newCodecs.some((newCodec) => {\n            return oldCodecs.indexOf(newCodec) > -1;\n        });\n\n        const partialCodecMatch = newCodecs.some((newCodec) => oldCodecs.some((oldCodec) => codecRootCompatibleWithCodec(oldCodec, newCodec)));\n        return codecMatch || (partialCodecMatch && sameMimeType);\n    }\n\n    // Check if the root of the old codec is the same as the new one, or if it's declared as compatible in the compat table\n    function codecRootCompatibleWithCodec(codec1, codec2) {\n        const codecRoot = codec1.split('.')[0];\n        const rootCompatible = codec2.indexOf(codecRoot) === 0;\n        let compatTableCodec;\n        for (let i = 0; i < codecCompatibilityTable.length; i++) {\n            if (codecCompatibilityTable[i].codec === codecRoot) {\n                compatTableCodec = codecCompatibilityTable[i];\n                break;\n            }\n        }\n        if (compatTableCodec) {\n            return rootCompatible || compatTableCodec.compatibleCodecs.some((compatibleCodec) => codec2.indexOf(compatibleCodec) === 0);\n        }\n        return rootCompatible;\n    }\n\n    function setPreloaded(value) {\n        preloaded = value;\n    }\n\n    function getPreloaded() {\n        return preloaded;\n    }\n\n    function preload(mediaSource, previousBuffers) {\n        addInlineEvents();\n\n        initializeMediaForType(Constants.VIDEO, mediaSource);\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        createBuffers(previousBuffers);\n\n        eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n        for (let i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\n            streamProcessors[i].getScheduleController().start();\n        }\n\n        setPreloaded(true);\n    }\n\n\n    instance = {\n        initialize: initialize,\n        activate: activate,\n        deactivate: deactivate,\n        isActive: isActive,\n        getDuration: getDuration,\n        getStartTime: getStartTime,\n        getId: getId,\n        getStreamInfo: getStreamInfo,\n        getHasAudioTrack: getHasAudioTrack,\n        getHasVideoTrack: getHasVideoTrack,\n        preload: preload,\n        getThumbnailController: getThumbnailController,\n        getBitrateListFor: getBitrateListFor,\n        updateData: updateData,\n        reset: reset,\n        getProcessors: getProcessors,\n        setMediaSource: setMediaSource,\n        isMediaCodecCompatible: isMediaCodecCompatible,\n        isProtectionCompatible: isProtectionCompatible,\n        getPreloaded: getPreloaded\n    };\n\n    setup();\n    return instance;\n}\n\nStream.__dashjs_factory_name = 'Stream';\nexport default FactoryMaker.getClassFactory(Stream);\n"]}